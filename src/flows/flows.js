import {
    sendTextMessage,
    sendQuickReplies,
    sendGenericTemplate,
    sendButtonMessage,
    sendMediaMessage,
    sendListTemplate,
    sendMediaTemplate,
    sendOneTimeNotificationRequest,
} from "../services/facebook.service.js";

// L∆∞u tr·∫°ng th√°i flow c·ªßa t·ª´ng user
const userFlowState = new Map();

export async function sendNode(node, senderId) {
    switch (node.type) {
        case "text": {
            await sendTextMessage(senderId, node.payload.text);
            break;
        }

        case "quick_replies": {
            const { text, replies } = node.payload;
            const formattedReplies = replies.map((r) => ({
                content_type: "text",
                title: r.title,
                payload: r.payload,
            }));
            await sendQuickReplies(senderId, text, formattedReplies);
            break;
        }

        case "button_template": {
            const { text, buttons } = node.payload;
            // L∆∞u tr·∫°ng th√°i node hi·ªán t·∫°i khi hi·ªÉn th·ªã button template
            userFlowState.set(senderId, {
                currentNode: node,
                isFromDefault: false,
            });
            await sendButtonMessage(senderId, text, buttons);
            break;
        }

        case "generic_template": {
            // L∆∞u tr·∫°ng th√°i node hi·ªán t·∫°i khi hi·ªÉn th·ªã generic template
            userFlowState.set(senderId, {
                currentNode: node,
                isFromDefault: false,
            });
            await sendGenericTemplate(senderId, node.payload.elements);
            break;
        }

        case "list_template": {
            const { elements, buttons = [] } = node.payload;
            // L∆∞u tr·∫°ng th√°i node hi·ªán t·∫°i khi hi·ªÉn th·ªã list template
            userFlowState.set(senderId, {
                currentNode: node,
                isFromDefault: false,
            });

            // ƒê·∫£m b·∫£o elements kh√¥ng v∆∞·ª£t qu√° 4 items
            const limitedElements = elements.slice(0, 4);

            // ƒê·∫£m b·∫£o m·ªói element c√≥ ƒë·∫ßy ƒë·ªß c√°c tr∆∞·ªùng b·∫Øt bu·ªôc
            const validElements = limitedElements.map((element) => ({
                title: element.title || "",
                subtitle: element.subtitle || "",
                image_url: element.image_url || "https://via.placeholder.com/300x200",
                default_action: element.default_action || {
                    type: "web_url",
                    url: "https://www.facebook.com",
                },
            }));

            try {
                await sendListTemplate(senderId, validElements, buttons);
            } catch (error) {
                console.error("Error sending list template:", error);
                // Fallback to text message if list template fails
                await sendTextMessage(senderId, "Xin l·ªói, c√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i sau.");
            }
            break;
        }

        case "media_template": {
            const { media_type, url, buttons = [] } = node.payload;
            // L∆∞u tr·∫°ng th√°i node hi·ªán t·∫°i khi hi·ªÉn th·ªã media template
            userFlowState.set(senderId, {
                currentNode: node,
                isFromDefault: false,
            });

            try {
                await sendMediaTemplate(senderId, media_type, url, buttons);
            } catch (error) {
                console.error("Error sending media template:", error);
                // Fallback to text message if media template fails
                await sendTextMessage(senderId, "Xin l·ªói, c√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i sau.");
            }
            break;
        }

        case "media": {
            const { type, url } = node.payload; // image, video, audio, file
            await sendMediaMessage(senderId, type, url);
            break;
        }

        case "one_time_notif": {
            const { text, payload } = node.payload;
            await sendOneTimeNotificationRequest(senderId, text, payload);
            break;
        }

        default: {
            console.warn("‚ö†Ô∏è Unknown node type:", node.type);
            break;
        }
    }
}

async function runNext(next, userInput, context) {
    if (Array.isArray(next)) {
        for (const n of next) {
            await runFlow(n, userInput, context); // truy·ªÅn nguy√™n context
        }
    } else {
        await runFlow(next, userInput, context);
    }
}

export async function runFlow(node, userInput, context = {}) {
    const { senderId, isFromDefault = false, inputType } = context;

    // N·∫øu ƒëang t·ª´ default m√† l·∫°i v√†o default n·ªØa ‚Üí ch·∫∑n v√≤ng l·∫∑p
    if (isFromDefault && node.id === "unknown") {
        console.log("üõë D·ª´ng v√≤ng l·∫∑p default.");
        return;
    }

    // Ki·ªÉm tra xem c√≥ ƒëang ƒë·ª£i input t·ª´ c√°c template kh√¥ng
    const currentState = userFlowState.get(senderId);
    if (currentState?.currentNode) {
        console.log("üìù Current state:", {
            type: currentState.currentNode.type,
            id: currentState.currentNode.id,
            input: userInput,
            inputType,
        });

        // X√≥a tr·∫°ng th√°i c≈©
        userFlowState.delete(senderId);

        // X·ª≠ l√Ω input d·ª±a tr√™n lo·∫°i template
        switch (currentState.currentNode.type) {
            case "quick_replies": {
                const matchedReply = currentState.currentNode.payload.replies.find(
                    (reply) => reply.title === userInput || reply.payload === userInput
                );

                if (matchedReply) {
                    console.log("‚úÖ Matched quick reply:", matchedReply.payload);
                    if (currentState.currentNode.condition) {
                        const matchedBranch = currentState.currentNode.condition.branches?.find(
                            (branch) => branch.value === matchedReply.payload
                        );

                        if (matchedBranch) {
                            await runNext(matchedBranch.next, matchedReply.payload, {
                                senderId,
                                isFromDefault: currentState.isFromDefault,
                                inputType,
                            });
                        } else if (currentState.currentNode.condition.default) {
                            await runNext(currentState.currentNode.condition.default, matchedReply.payload, {
                                senderId,
                                isFromDefault: true,
                                inputType,
                            });
                        }
                    } else if (currentState.currentNode.next) {
                        await runNext(currentState.currentNode.next, matchedReply.payload, {
                            senderId,
                            isFromDefault: currentState.isFromDefault,
                            inputType,
                        });
                    }
                } else if (currentState.currentNode.condition?.default) {
                    await runNext(currentState.currentNode.condition.default, userInput, {
                        senderId,
                        isFromDefault: true,
                        inputType,
                    });
                }
                break;
            }

            case "media_template":
            case "list_template":
            case "generic_template":
            case "button_template": {
                if (inputType === "postback") {
                    if (currentState.currentNode.condition) {
                        const matchedBranch = currentState.currentNode.condition.branches?.find((branch) => branch.value === userInput);

                        if (matchedBranch) {
                            console.log("‚úÖ Matched branch:", matchedBranch.value);
                            await runNext(matchedBranch.next, userInput, {
                                senderId,
                                isFromDefault: currentState.isFromDefault,
                                inputType,
                            });
                        } else if (currentState.currentNode.condition.default) {
                            console.log("‚ö†Ô∏è No matching branch, using default");
                            await runNext(currentState.currentNode.condition.default, userInput, {
                                senderId,
                                isFromDefault: true,
                                inputType,
                            });
                        }
                    } else if (currentState.currentNode.next) {
                        console.log("‚û°Ô∏è No condition, using next node");
                        await runNext(currentState.currentNode.next, userInput, {
                            senderId,
                            isFromDefault: currentState.isFromDefault,
                            inputType,
                        });
                    }
                } else {
                    console.log("‚ö†Ô∏è Expected postback but got:", inputType);
                    if (currentState.currentNode.condition?.default) {
                        await runNext(currentState.currentNode.condition.default, userInput, {
                            senderId,
                            isFromDefault: true,
                            inputType,
                        });
                    }
                }
                break;
            }
        }
        return;
    }

    // N·∫øu l√† quick replies, l∆∞u node hi·ªán t·∫°i v√† ƒë·ª£i input
    if (node.type === "quick_replies") {
        userFlowState.set(senderId, {
            currentNode: node,
            isFromDefault,
        });
        await sendNode(node, senderId);
        return;
    }

    await sendNode(node, senderId);

    // N·∫øu c√≥ ƒëi·ªÅu ki·ªán
    if (node.condition) {
        const matchedBranch = node.condition.branches?.find((branch) => branch.value === userInput);

        if (matchedBranch) {
            await runNext(matchedBranch.next, userInput, {
                senderId,
                isFromDefault: false,
                inputType,
            });
        } else if (node.condition.default) {
            await runNext(node.condition.default, userInput, {
                senderId,
                isFromDefault: true,
                inputType,
            });
        }

        return;
    }

    if (node.next) {
        await runNext(node.next, userInput, {
            senderId,
            isFromDefault: false,
            inputType,
        });
    }
}
